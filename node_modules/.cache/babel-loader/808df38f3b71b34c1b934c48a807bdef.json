{"ast":null,"code":"import _slicedToArray from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/wubenqi/nebula-chat/telegram-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/*\n *  Copyright (c) 2018-present, Evgeny Nadymov\n *\n * This source code is licensed under the GPL v.3.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport EventEmitter from './EventEmitter';\nimport { isMessageMuted } from '../Utils/Store';\nimport { APP_NAME, NOTIFICATION_AUDIO_DELAY_MS } from '../Constants';\nimport ChatStore from './ChatStore';\nimport MessageStore from './MessageStore';\nimport TdLibController from '../Controllers/TdLibController';\n\nvar NotificationStore =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(NotificationStore, _EventEmitter);\n\n  function NotificationStore() {\n    var _this;\n\n    _classCallCheck(this, NotificationStore);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NotificationStore).call(this));\n\n    _this.reset = function () {\n      // depends on ChatStore and MessageStore updates\n      _this.chatStore = ChatStore;\n      _this.messageStore = MessageStore;\n      _this.appInactive = false;\n      _this.newMessages = new Map();\n      _this.settings = new Map();\n      _this.windowFocused = true;\n      _this.timerHandler = null;\n      _this.nextSoundAt = new Date();\n      _this.enableSound = false;\n    };\n\n    _this.onTimer = function () {\n      // console.log('[ns] onTimer');\n      var unreadCount = _this.getUnreadCount();\n\n      var showBadge = document.title === APP_NAME && unreadCount > 0;\n\n      if (showBadge) {\n        var title = '+99 notifications';\n\n        if (unreadCount === 1) {\n          title = '1 notification';\n        } else if (unreadCount < 99) {\n          title = \"\".concat(unreadCount, \" notifications\");\n        }\n\n        document.title = title;\n        document.getElementById('favicon').href = 'favicon_unread.ico';\n      } else {\n        document.title = APP_NAME + (_this.appInactive ? ': Zzz…' : '');\n        document.getElementById('favicon').href = 'favicon.ico';\n      }\n    };\n\n    _this.onUpdate = function (update) {\n      switch (update['@type']) {\n        case 'updateAuthorizationState':\n          {\n            var authorization_state = update.authorization_state;\n            if (!authorization_state) break;\n\n            switch (authorization_state['@type']) {\n              case 'authorizationStateClosed':\n                {\n                  _this.reset();\n\n                  break;\n                }\n            }\n\n            break;\n          }\n\n        case 'updateChatReadInbox':\n          {\n            var _assertThisInitialize = _assertThisInitialized(_this),\n                windowFocused = _assertThisInitialize.windowFocused;\n\n            if (!windowFocused) {\n              var chat_id = update.chat_id,\n                  last_read_inbox_message_id = update.last_read_inbox_message_id;\n\n              var chatMap = _this.newMessages.get(chat_id);\n\n              if (chatMap) {\n                var newChatMap = new Map(_toConsumableArray(chatMap).filter(function (_ref) {\n                  var _ref2 = _slicedToArray(_ref, 2),\n                      id = _ref2[0],\n                      m = _ref2[1];\n\n                  return m.id > last_read_inbox_message_id;\n                }));\n\n                if (newChatMap.size < chatMap.size) {\n                  _this.newMessages.set(chat_id, newChatMap);\n\n                  _this.updateTimer();\n                }\n              }\n            }\n\n            break;\n          }\n\n        case 'updateChatNotificationSettings':\n          {\n            var _assertThisInitialize2 = _assertThisInitialized(_this),\n                _windowFocused = _assertThisInitialize2.windowFocused;\n\n            if (!_windowFocused) {\n              _this.updateTimer();\n            }\n\n            break;\n          }\n\n        case 'updateDeleteMessages':\n          {\n            var _assertThisInitialize3 = _assertThisInitialized(_this),\n                _windowFocused2 = _assertThisInitialize3.windowFocused;\n\n            if (!_windowFocused2) {\n              var _chat_id = update.chat_id,\n                  message_ids = update.message_ids,\n                  is_permanent = update.is_permanent;\n\n              if (is_permanent && message_ids.length > 0) {\n                var _chatMap = _this.newMessages.get(_chat_id);\n\n                if (_chatMap) {\n                  var filterMap = new Map(message_ids.map(function (id) {\n                    return [id, id];\n                  }));\n\n                  var _newChatMap = new Map(_toConsumableArray(_chatMap).filter(function (_ref3) {\n                    var _ref4 = _slicedToArray(_ref3, 2),\n                        id = _ref4[0],\n                        m = _ref4[1];\n\n                    return !filterMap.has(id);\n                  }));\n\n                  if (_newChatMap.size < _chatMap.size) {\n                    _this.newMessages.set(_chat_id, _newChatMap);\n\n                    _this.updateTimer();\n                  }\n                }\n              }\n            }\n\n            break;\n          }\n\n        case 'updateNewMessage':\n          {\n            var _assertThisInitialize4 = _assertThisInitialized(_this),\n                _windowFocused3 = _assertThisInitialize4.windowFocused; // console.log('[ns] updateNewMessage', windowFocused);\n\n\n            if (!_windowFocused3) {\n              var message = update.message;\n              var _chat_id2 = message.chat_id,\n                  id = message.id;\n\n              var _chatMap2 = _this.newMessages.get(_chat_id2) || new Map();\n\n              _chatMap2.set(id, message);\n\n              _this.newMessages.set(_chat_id2, _chatMap2);\n\n              _this.updateTimer();\n\n              if (!message.is_outgoing && !isMessageMuted(message) && _this.enableSound) {\n                var now = new Date();\n\n                if (now > _this.nextSoundAt) {\n                  // console.log('[ns] audio play');\n                  try {\n                    var audio = new Audio('sound_a.mp3');\n                    audio.play();\n                  } catch (_unused) {}\n\n                  var nextSoundAt = new Date();\n                  nextSoundAt.setMilliseconds(nextSoundAt.getMilliseconds() + NOTIFICATION_AUDIO_DELAY_MS);\n                  _this.nextSoundAt = nextSoundAt;\n                }\n              }\n            }\n\n            break;\n          }\n\n        case 'updateScopeNotificationSettings':\n          {\n            var scope = update.scope,\n                notification_settings = update.notification_settings;\n\n            _this.settings.set(scope['@type'], notification_settings);\n\n            var _assertThisInitialize5 = _assertThisInitialized(_this),\n                _windowFocused4 = _assertThisInitialize5.windowFocused;\n\n            if (!_windowFocused4) {\n              _this.updateTimer();\n            }\n\n            _this.emit('updateScopeNotificationSettings', update);\n\n            break;\n          }\n\n        default:\n          break;\n      }\n    };\n\n    _this.onClientUpdate = function (update) {\n      switch (update['@type']) {\n        case 'clientUpdateAppInactive':\n          {\n            _this.appInactive = true;\n            _this.newMessages = new Map();\n\n            _this.updateTimer();\n\n            break;\n          }\n\n        case 'clientUpdateFocusWindow':\n          {\n            var focused = update.focused; // console.log('[ns] clientUpdateFocusWindow', update);\n\n            _this.windowFocused = focused;\n\n            if (focused) {\n              _this.newMessages = new Map();\n\n              _this.updateTimer();\n            }\n\n            break;\n          }\n\n        default:\n          break;\n      }\n    };\n\n    _this.addTdLibListener = function () {\n      TdLibController.on('update', _this.onUpdate);\n      TdLibController.on('clientUpdate', _this.onClientUpdate);\n    };\n\n    _this.removeTdLibListener = function () {\n      TdLibController.off('update', _this.onUpdate);\n      TdLibController.off('clientUpdate', _this.onClientUpdate);\n    };\n\n    _this.reset();\n\n    _this.addTdLibListener();\n\n    return _this;\n  }\n\n  _createClass(NotificationStore, [{\n    key: \"getUnreadCount\",\n    value: function getUnreadCount() {\n      var unreadCount = 0;\n      this.newMessages.forEach(function (chat) {\n        chat.forEach(function (m) {\n          if (!m.is_outgoing && !isMessageMuted(m)) {\n            unreadCount++;\n          }\n        });\n      });\n      return unreadCount;\n    }\n  }, {\n    key: \"updateTimer\",\n    value: function updateTimer() {\n      var unreadCount = this.getUnreadCount(); // console.log('[ns] updateTimer', unreadCount, this.newMessages);\n\n      if (unreadCount > 0) {\n        if (!this.timerHandler) {\n          // console.log('[ns] setInterval');\n          this.onTimer();\n          this.timerHandler = setInterval(this.onTimer, 1000);\n        }\n      } else {\n        if (this.timerHandler) {\n          // console.log('[ns] clearInterval');\n          clearInterval(this.timerHandler);\n          this.timerHandler = null;\n          this.onTimer();\n        }\n      }\n    }\n  }]);\n\n  return NotificationStore;\n}(EventEmitter);\n\nvar store = new NotificationStore();\nwindow.notifications = store;\nexport default store;","map":{"version":3,"sources":["/Users/wubenqi/nebula-chat/telegram-react/src/Stores/NotificationStore.js"],"names":["EventEmitter","isMessageMuted","APP_NAME","NOTIFICATION_AUDIO_DELAY_MS","ChatStore","MessageStore","TdLibController","NotificationStore","reset","chatStore","messageStore","appInactive","newMessages","Map","settings","windowFocused","timerHandler","nextSoundAt","Date","enableSound","onTimer","unreadCount","getUnreadCount","showBadge","document","title","getElementById","href","onUpdate","update","authorization_state","chat_id","last_read_inbox_message_id","chatMap","get","newChatMap","filter","id","m","size","set","updateTimer","message_ids","is_permanent","length","filterMap","map","has","message","is_outgoing","now","audio","Audio","play","setMilliseconds","getMilliseconds","scope","notification_settings","emit","onClientUpdate","focused","addTdLibListener","on","removeTdLibListener","off","forEach","chat","setInterval","clearInterval","store","window","notifications"],"mappings":"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","sourcesContent":["/*\n *  Copyright (c) 2018-present, Evgeny Nadymov\n *\n * This source code is licensed under the GPL v.3.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport EventEmitter from './EventEmitter';\nimport { isMessageMuted } from '../Utils/Store';\nimport { APP_NAME, NOTIFICATION_AUDIO_DELAY_MS } from '../Constants';\nimport ChatStore from './ChatStore';\nimport MessageStore from './MessageStore';\nimport TdLibController from '../Controllers/TdLibController';\n\nclass NotificationStore extends EventEmitter {\n    constructor() {\n        super();\n\n        this.reset();\n\n        this.addTdLibListener();\n    }\n\n    reset = () => {\n        // depends on ChatStore and MessageStore updates\n        this.chatStore = ChatStore;\n        this.messageStore = MessageStore;\n\n        this.appInactive = false;\n        this.newMessages = new Map();\n        this.settings = new Map();\n        this.windowFocused = true;\n        this.timerHandler = null;\n        this.nextSoundAt = new Date();\n        this.enableSound = false;\n    };\n\n    getUnreadCount() {\n        let unreadCount = 0;\n        this.newMessages.forEach(chat => {\n            chat.forEach(m => {\n                if (!m.is_outgoing && !isMessageMuted(m)) {\n                    unreadCount++;\n                }\n            });\n        });\n\n        return unreadCount;\n    }\n\n    updateTimer() {\n        const unreadCount = this.getUnreadCount();\n        // console.log('[ns] updateTimer', unreadCount, this.newMessages);\n\n        if (unreadCount > 0) {\n            if (!this.timerHandler) {\n                // console.log('[ns] setInterval');\n\n                this.onTimer();\n                this.timerHandler = setInterval(this.onTimer, 1000);\n            }\n        } else {\n            if (this.timerHandler) {\n                // console.log('[ns] clearInterval');\n\n                clearInterval(this.timerHandler);\n                this.timerHandler = null;\n                this.onTimer();\n            }\n        }\n    }\n\n    onTimer = () => {\n        // console.log('[ns] onTimer');\n\n        const unreadCount = this.getUnreadCount();\n        const showBadge = document.title === APP_NAME && unreadCount > 0;\n\n        if (showBadge) {\n            let title = '+99 notifications';\n            if (unreadCount === 1) {\n                title = '1 notification';\n            } else if (unreadCount < 99) {\n                title = `${unreadCount} notifications`;\n            }\n            document.title = title;\n            document.getElementById('favicon').href = 'favicon_unread.ico';\n        } else {\n            document.title = APP_NAME + (this.appInactive ? ': Zzz…' : '');\n            document.getElementById('favicon').href = 'favicon.ico';\n        }\n    };\n\n    onUpdate = update => {\n        switch (update['@type']) {\n            case 'updateAuthorizationState': {\n                const { authorization_state } = update;\n                if (!authorization_state) break;\n\n                switch (authorization_state['@type']) {\n                    case 'authorizationStateClosed': {\n                        this.reset();\n                        break;\n                    }\n                }\n\n                break;\n            }\n            case 'updateChatReadInbox': {\n                const { windowFocused } = this;\n                if (!windowFocused) {\n                    const { chat_id, last_read_inbox_message_id } = update;\n\n                    const chatMap = this.newMessages.get(chat_id);\n                    if (chatMap) {\n                        const newChatMap = new Map([...chatMap].filter(([id, m]) => m.id > last_read_inbox_message_id));\n                        if (newChatMap.size < chatMap.size) {\n                            this.newMessages.set(chat_id, newChatMap);\n                            this.updateTimer();\n                        }\n                    }\n                }\n\n                break;\n            }\n            case 'updateChatNotificationSettings': {\n                const { windowFocused } = this;\n                if (!windowFocused) {\n                    this.updateTimer();\n                }\n\n                break;\n            }\n            case 'updateDeleteMessages': {\n                const { windowFocused } = this;\n                if (!windowFocused) {\n                    const { chat_id, message_ids, is_permanent } = update;\n                    if (is_permanent && message_ids.length > 0) {\n                        const chatMap = this.newMessages.get(chat_id);\n                        if (chatMap) {\n                            const filterMap = new Map(message_ids.map(id => [id, id]));\n\n                            const newChatMap = new Map([...chatMap].filter(([id, m]) => !filterMap.has(id)));\n                            if (newChatMap.size < chatMap.size) {\n                                this.newMessages.set(chat_id, newChatMap);\n                                this.updateTimer();\n                            }\n                        }\n                    }\n                }\n\n                break;\n            }\n            case 'updateNewMessage': {\n                const { windowFocused } = this;\n                // console.log('[ns] updateNewMessage', windowFocused);\n                if (!windowFocused) {\n                    const { message } = update;\n                    const { chat_id, id } = message;\n\n                    const chatMap = this.newMessages.get(chat_id) || new Map();\n                    chatMap.set(id, message);\n                    this.newMessages.set(chat_id, chatMap);\n                    this.updateTimer();\n\n                    if (!message.is_outgoing && !isMessageMuted(message) && this.enableSound) {\n                        const now = new Date();\n                        if (now > this.nextSoundAt) {\n                            // console.log('[ns] audio play');\n                            try {\n                                const audio = new Audio('sound_a.mp3');\n                                audio.play();\n                            } catch {\n\n                            }\n\n                            const nextSoundAt = new Date();\n                            nextSoundAt.setMilliseconds(nextSoundAt.getMilliseconds() + NOTIFICATION_AUDIO_DELAY_MS);\n                            this.nextSoundAt = nextSoundAt;\n                        }\n                    }\n                }\n\n                break;\n            }\n            case 'updateScopeNotificationSettings': {\n                const { scope, notification_settings } = update;\n\n                this.settings.set(scope['@type'], notification_settings);\n\n                const { windowFocused } = this;\n                if (!windowFocused) {\n                    this.updateTimer();\n                }\n\n                this.emit('updateScopeNotificationSettings', update);\n                break;\n            }\n            default:\n                break;\n        }\n    };\n\n    onClientUpdate = update => {\n        switch (update['@type']) {\n            case 'clientUpdateAppInactive': {\n                this.appInactive = true;\n                this.newMessages = new Map();\n                this.updateTimer();\n                break;\n            }\n            case 'clientUpdateFocusWindow': {\n                const { focused } = update;\n                // console.log('[ns] clientUpdateFocusWindow', update);\n\n                this.windowFocused = focused;\n                if (focused) {\n                    this.newMessages = new Map();\n                    this.updateTimer();\n                }\n\n                break;\n            }\n            default:\n                break;\n        }\n    };\n\n    addTdLibListener = () => {\n        TdLibController.on('update', this.onUpdate);\n        TdLibController.on('clientUpdate', this.onClientUpdate);\n    };\n\n    removeTdLibListener = () => {\n        TdLibController.off('update', this.onUpdate);\n        TdLibController.off('clientUpdate', this.onClientUpdate);\n    };\n}\n\nconst store = new NotificationStore();\nwindow.notifications = store;\nexport default store;\n"]},"metadata":{},"sourceType":"module"}