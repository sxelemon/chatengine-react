{"ast":null,"code":"//https://stackoverflow.com/questions/183485/converting-punycode-with-dash-character-to-unicode\n//Javascript Punycode converter derived from example in RFC3492.\n//This implementation is created by some@domain.name and released into public domain\nfunction Punycode() {\n  // This object converts to and from puny-code used in IDN\n  //\n  // punycode.ToASCII ( domain )\n  //\n  // Returns a puny coded representation of \"domain\".\n  // It only converts the part of the domain name that\n  // has non ASCII characters. I.e. it dosent matter if\n  // you call it with a domain that already is in ASCII.\n  //\n  // punycode.ToUnicode (domain)\n  //\n  // Converts a puny-coded domain name to unicode.\n  // It only converts the puny-coded parts of the domain name.\n  // I.e. it dosent matter if you call it on a string\n  // that already has been converted to unicode.\n  //\n  //\n  this.utf16 = {\n    // The utf16-class is necessary to convert from javascripts internal character representation to unicode and back.\n    decode: function decode(input) {\n      var output = [],\n          i = 0,\n          len = input.length,\n          value,\n          extra;\n\n      while (i < len) {\n        value = input.charCodeAt(i++);\n\n        if ((value & 0xf800) === 0xd800) {\n          extra = input.charCodeAt(i++);\n\n          if ((value & 0xfc00) !== 0xd800 || (extra & 0xfc00) !== 0xdc00) {\n            throw new RangeError('UTF-16(decode): Illegal UTF-16 sequence');\n          }\n\n          value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n        }\n\n        output.push(value);\n      }\n\n      return output;\n    },\n    encode: function encode(input) {\n      var output = [],\n          i = 0,\n          len = input.length,\n          value;\n\n      while (i < len) {\n        value = input[i++];\n\n        if ((value & 0xf800) === 0xd800) {\n          throw new RangeError('UTF-16(encode): Illegal UTF-16 value');\n        }\n\n        if (value > 0xffff) {\n          value -= 0x10000;\n          output.push(String.fromCharCode(value >>> 10 & 0x3ff | 0xd800));\n          value = 0xdc00 | value & 0x3ff;\n        }\n\n        output.push(String.fromCharCode(value));\n      }\n\n      return output.join('');\n    }\n  }; //Default parameters\n\n  var initial_n = 0x80;\n  var initial_bias = 72;\n  var delimiter = '\\x2D';\n  var base = 36;\n  var damp = 700;\n  var tmin = 1;\n  var tmax = 26;\n  var skew = 38;\n  var maxint = 0x7fffffff; // decode_digit(cp) returns the numeric value of a basic code\n  // point (for use in representing integers) in the range 0 to\n  // base-1, or base if cp is does not represent a value.\n\n  function decode_digit(cp) {\n    return cp - 48 < 10 ? cp - 22 : cp - 65 < 26 ? cp - 65 : cp - 97 < 26 ? cp - 97 : base;\n  } // encode_digit(d,flag) returns the basic code point whose value\n  // (when used for representing integers) is d, which needs to be in\n  // the range 0 to base-1. The lowercase form is used unless flag is\n  // nonzero, in which case the uppercase form is used. The behavior\n  // is undefined if flag is nonzero and digit d has no uppercase form.\n\n\n  function encode_digit(d, flag) {\n    return d + 22 + 75 * (d < 26) - ((flag != 0) << 5); //  0..25 map to ASCII a..z or A..Z\n    // 26..35 map to ASCII 0..9\n  } //** Bias adaptation function **\n\n\n  function adapt(delta, numpoints, firsttime) {\n    var k;\n    delta = firsttime ? Math.floor(delta / damp) : delta >> 1;\n    delta += Math.floor(delta / numpoints);\n\n    for (k = 0; delta > (base - tmin) * tmax >> 1; k += base) {\n      delta = Math.floor(delta / (base - tmin));\n    }\n\n    return Math.floor(k + (base - tmin + 1) * delta / (delta + skew));\n  } // encode_basic(bcp,flag) forces a basic code point to lowercase if flag is zero,\n  // uppercase if flag is nonzero, and returns the resulting code point.\n  // The code point is unchanged if it is caseless.\n  // The behavior is undefined if bcp is not a basic code point.\n\n\n  function encode_basic(bcp, flag) {\n    bcp -= (bcp - 97 < 26) << 5;\n    return bcp + ((!flag && bcp - 65 < 26) << 5);\n  } // Main decode\n\n\n  this.decode = function (input, preserveCase) {\n    // Dont use utf16\n    var output = [];\n    var case_flags = [];\n    var input_length = input.length;\n    var n, out, i, bias, basic, j, ic, oldi, w, k, digit, t, len; // Initialize the state:\n\n    n = initial_n;\n    i = 0;\n    bias = initial_bias; // Handle the basic code points: Let basic be the number of input code\n    // points before the last delimiter, or 0 if there is none, then\n    // copy the first basic code points to the output.\n\n    basic = input.lastIndexOf(delimiter);\n    if (basic < 0) basic = 0;\n\n    for (j = 0; j < basic; ++j) {\n      if (preserveCase) case_flags[output.length] = input.charCodeAt(j) - 65 < 26;\n\n      if (input.charCodeAt(j) >= 0x80) {\n        throw new RangeError('Illegal input >= 0x80');\n      }\n\n      output.push(input.charCodeAt(j));\n    } // Main decoding loop: Start just after the last delimiter if any\n    // basic code points were copied; start at the beginning otherwise.\n\n\n    for (ic = basic > 0 ? basic + 1 : 0; ic < input_length;) {\n      // ic is the index of the next character to be consumed,\n      // Decode a generalized variable-length integer into delta,\n      // which gets added to i. The overflow checking is easier\n      // if we increase i as we go, then subtract off its starting\n      // value at the end to obtain delta.\n      for (oldi = i, w = 1, k = base;; k += base) {\n        if (ic >= input_length) {\n          throw RangeError('punycode_bad_input(1)');\n        }\n\n        digit = decode_digit(input.charCodeAt(ic++));\n\n        if (digit >= base) {\n          throw RangeError('punycode_bad_input(2)');\n        }\n\n        if (digit > Math.floor((maxint - i) / w)) {\n          throw RangeError('punycode_overflow(1)');\n        }\n\n        i += digit * w;\n        t = k <= bias ? tmin : k >= bias + tmax ? tmax : k - bias;\n\n        if (digit < t) {\n          break;\n        }\n\n        if (w > Math.floor(maxint / (base - t))) {\n          throw RangeError('punycode_overflow(2)');\n        }\n\n        w *= base - t;\n      }\n\n      out = output.length + 1;\n      bias = adapt(i - oldi, out, oldi === 0); // i was supposed to wrap around from out to 0,\n      // incrementing n each time, so we'll fix that now:\n\n      if (Math.floor(i / out) > maxint - n) {\n        throw RangeError('punycode_overflow(3)');\n      }\n\n      n += Math.floor(i / out);\n      i %= out; // Insert n at position i of the output:\n      // Case of last character determines uppercase flag:\n\n      if (preserveCase) {\n        case_flags.splice(i, 0, input.charCodeAt(ic - 1) - 65 < 26);\n      }\n\n      output.splice(i, 0, n);\n      i++;\n    }\n\n    if (preserveCase) {\n      for (i = 0, len = output.length; i < len; i++) {\n        if (case_flags[i]) {\n          output[i] = String.fromCharCode(output[i]).toUpperCase().charCodeAt(0);\n        }\n      }\n    }\n\n    return this.utf16.encode(output);\n  }; //** Main encode function **\n\n\n  this.encode = function (input, preserveCase) {\n    //** Bias adaptation function **\n    var n, delta, h, b, bias, j, m, q, k, t, ijv, case_flags;\n\n    if (preserveCase) {\n      // Preserve case, step1 of 2: Get a list of the unaltered string\n      case_flags = this.utf16.decode(input);\n    } // Converts the input in UTF-16 to Unicode\n\n\n    input = this.utf16.decode(input.toLowerCase());\n    var input_length = input.length; // Cache the length\n\n    if (preserveCase) {\n      // Preserve case, step2 of 2: Modify the list to true/false\n      for (j = 0; j < input_length; j++) {\n        case_flags[j] = input[j] != case_flags[j];\n      }\n    }\n\n    var output = []; // Initialize the state:\n\n    n = initial_n;\n    delta = 0;\n    bias = initial_bias; // Handle the basic code points:\n\n    for (j = 0; j < input_length; ++j) {\n      if (input[j] < 0x80) {\n        output.push(String.fromCharCode(case_flags ? encode_basic(input[j], case_flags[j]) : input[j]));\n      }\n    }\n\n    h = b = output.length; // h is the number of code points that have been handled, b is the\n    // number of basic code points\n\n    if (b > 0) output.push(delimiter); // Main encoding loop:\n    //\n\n    while (h < input_length) {\n      // All non-basic code points < n have been\n      // handled already. Find the next larger one:\n      for (m = maxint, j = 0; j < input_length; ++j) {\n        ijv = input[j];\n        if (ijv >= n && ijv < m) m = ijv;\n      } // Increase delta enough to advance the decoder's\n      // <n,i> state to <m,0>, but guard against overflow:\n\n\n      if (m - n > Math.floor((maxint - delta) / (h + 1))) {\n        throw RangeError('punycode_overflow (1)');\n      }\n\n      delta += (m - n) * (h + 1);\n      n = m;\n\n      for (j = 0; j < input_length; ++j) {\n        ijv = input[j];\n\n        if (ijv < n) {\n          if (++delta > maxint) return Error('punycode_overflow(2)');\n        }\n\n        if (ijv == n) {\n          // Represent delta as a generalized variable-length integer:\n          for (q = delta, k = base;; k += base) {\n            t = k <= bias ? tmin : k >= bias + tmax ? tmax : k - bias;\n            if (q < t) break;\n            output.push(String.fromCharCode(encode_digit(t + (q - t) % (base - t), 0)));\n            q = Math.floor((q - t) / (base - t));\n          }\n\n          output.push(String.fromCharCode(encode_digit(q, preserveCase && case_flags[j] ? 1 : 0)));\n          bias = adapt(delta, h + 1, h == b);\n          delta = 0;\n          ++h;\n        }\n      }\n\n      ++delta;\n      ++n;\n    }\n\n    return output.join('');\n  };\n\n  this.ToASCII = function (domain) {\n    var domain_array = domain.split('.');\n    var out = [];\n\n    for (var i = 0; i < domain_array.length; ++i) {\n      var s = domain_array[i];\n      out.push(s.match(/[^A-Za-z0-9-]/) ? 'xn--' + punycode.encode(s) : s);\n    }\n\n    return out.join('.');\n  };\n\n  this.ToUnicode = function (domain) {\n    var domain_array = domain.split('.');\n    var out = [];\n\n    for (var i = 0; i < domain_array.length; ++i) {\n      var s = domain_array[i];\n      out.push(s.match(/^xn--/) ? punycode.decode(s.slice(4)) : s);\n    }\n\n    return out.join('.');\n  };\n}\n\nvar punycode = new Punycode();\nexport default punycode;","map":{"version":3,"sources":["/Users/wubenqi/nebula-chat/telegram-react/src/Utils/Punycode.js"],"names":["Punycode","utf16","decode","input","output","i","len","length","value","extra","charCodeAt","RangeError","push","encode","String","fromCharCode","join","initial_n","initial_bias","delimiter","base","damp","tmin","tmax","skew","maxint","decode_digit","cp","encode_digit","d","flag","adapt","delta","numpoints","firsttime","k","Math","floor","encode_basic","bcp","preserveCase","case_flags","input_length","n","out","bias","basic","j","ic","oldi","w","digit","t","lastIndexOf","splice","toUpperCase","h","b","m","q","ijv","toLowerCase","Error","ToASCII","domain","domain_array","split","s","match","punycode","ToUnicode","slice"],"mappings":"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","sourcesContent":["//https://stackoverflow.com/questions/183485/converting-punycode-with-dash-character-to-unicode\n//Javascript Punycode converter derived from example in RFC3492.\n//This implementation is created by some@domain.name and released into public domain\nfunction Punycode() {\n    // This object converts to and from puny-code used in IDN\n    //\n    // punycode.ToASCII ( domain )\n    //\n    // Returns a puny coded representation of \"domain\".\n    // It only converts the part of the domain name that\n    // has non ASCII characters. I.e. it dosent matter if\n    // you call it with a domain that already is in ASCII.\n    //\n    // punycode.ToUnicode (domain)\n    //\n    // Converts a puny-coded domain name to unicode.\n    // It only converts the puny-coded parts of the domain name.\n    // I.e. it dosent matter if you call it on a string\n    // that already has been converted to unicode.\n    //\n    //\n    this.utf16 = {\n        // The utf16-class is necessary to convert from javascripts internal character representation to unicode and back.\n        decode: function(input) {\n            var output = [],\n                i = 0,\n                len = input.length,\n                value,\n                extra;\n            while (i < len) {\n                value = input.charCodeAt(i++);\n                if ((value & 0xf800) === 0xd800) {\n                    extra = input.charCodeAt(i++);\n                    if ((value & 0xfc00) !== 0xd800 || (extra & 0xfc00) !== 0xdc00) {\n                        throw new RangeError('UTF-16(decode): Illegal UTF-16 sequence');\n                    }\n                    value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                }\n                output.push(value);\n            }\n            return output;\n        },\n        encode: function(input) {\n            var output = [],\n                i = 0,\n                len = input.length,\n                value;\n            while (i < len) {\n                value = input[i++];\n                if ((value & 0xf800) === 0xd800) {\n                    throw new RangeError('UTF-16(encode): Illegal UTF-16 value');\n                }\n                if (value > 0xffff) {\n                    value -= 0x10000;\n                    output.push(String.fromCharCode(((value >>> 10) & 0x3ff) | 0xd800));\n                    value = 0xdc00 | (value & 0x3ff);\n                }\n                output.push(String.fromCharCode(value));\n            }\n            return output.join('');\n        }\n    };\n\n    //Default parameters\n    var initial_n = 0x80;\n    var initial_bias = 72;\n    var delimiter = '\\x2D';\n    var base = 36;\n    var damp = 700;\n    var tmin = 1;\n    var tmax = 26;\n    var skew = 38;\n    var maxint = 0x7fffffff;\n\n    // decode_digit(cp) returns the numeric value of a basic code\n    // point (for use in representing integers) in the range 0 to\n    // base-1, or base if cp is does not represent a value.\n\n    function decode_digit(cp) {\n        return cp - 48 < 10 ? cp - 22 : cp - 65 < 26 ? cp - 65 : cp - 97 < 26 ? cp - 97 : base;\n    }\n\n    // encode_digit(d,flag) returns the basic code point whose value\n    // (when used for representing integers) is d, which needs to be in\n    // the range 0 to base-1. The lowercase form is used unless flag is\n    // nonzero, in which case the uppercase form is used. The behavior\n    // is undefined if flag is nonzero and digit d has no uppercase form.\n\n    function encode_digit(d, flag) {\n        return d + 22 + 75 * (d < 26) - ((flag != 0) << 5);\n        //  0..25 map to ASCII a..z or A..Z\n        // 26..35 map to ASCII 0..9\n    }\n    //** Bias adaptation function **\n    function adapt(delta, numpoints, firsttime) {\n        var k;\n        delta = firsttime ? Math.floor(delta / damp) : delta >> 1;\n        delta += Math.floor(delta / numpoints);\n\n        for (k = 0; delta > ((base - tmin) * tmax) >> 1; k += base) {\n            delta = Math.floor(delta / (base - tmin));\n        }\n        return Math.floor(k + ((base - tmin + 1) * delta) / (delta + skew));\n    }\n\n    // encode_basic(bcp,flag) forces a basic code point to lowercase if flag is zero,\n    // uppercase if flag is nonzero, and returns the resulting code point.\n    // The code point is unchanged if it is caseless.\n    // The behavior is undefined if bcp is not a basic code point.\n\n    function encode_basic(bcp, flag) {\n        bcp -= (bcp - 97 < 26) << 5;\n        return bcp + ((!flag && bcp - 65 < 26) << 5);\n    }\n\n    // Main decode\n    this.decode = function(input, preserveCase) {\n        // Dont use utf16\n        var output = [];\n        var case_flags = [];\n        var input_length = input.length;\n\n        var n, out, i, bias, basic, j, ic, oldi, w, k, digit, t, len;\n\n        // Initialize the state:\n\n        n = initial_n;\n        i = 0;\n        bias = initial_bias;\n\n        // Handle the basic code points: Let basic be the number of input code\n        // points before the last delimiter, or 0 if there is none, then\n        // copy the first basic code points to the output.\n\n        basic = input.lastIndexOf(delimiter);\n        if (basic < 0) basic = 0;\n\n        for (j = 0; j < basic; ++j) {\n            if (preserveCase) case_flags[output.length] = input.charCodeAt(j) - 65 < 26;\n            if (input.charCodeAt(j) >= 0x80) {\n                throw new RangeError('Illegal input >= 0x80');\n            }\n            output.push(input.charCodeAt(j));\n        }\n\n        // Main decoding loop: Start just after the last delimiter if any\n        // basic code points were copied; start at the beginning otherwise.\n\n        for (ic = basic > 0 ? basic + 1 : 0; ic < input_length; ) {\n            // ic is the index of the next character to be consumed,\n\n            // Decode a generalized variable-length integer into delta,\n            // which gets added to i. The overflow checking is easier\n            // if we increase i as we go, then subtract off its starting\n            // value at the end to obtain delta.\n            for (oldi = i, w = 1, k = base; ; k += base) {\n                if (ic >= input_length) {\n                    throw RangeError('punycode_bad_input(1)');\n                }\n                digit = decode_digit(input.charCodeAt(ic++));\n\n                if (digit >= base) {\n                    throw RangeError('punycode_bad_input(2)');\n                }\n                if (digit > Math.floor((maxint - i) / w)) {\n                    throw RangeError('punycode_overflow(1)');\n                }\n                i += digit * w;\n                t = k <= bias ? tmin : k >= bias + tmax ? tmax : k - bias;\n                if (digit < t) {\n                    break;\n                }\n                if (w > Math.floor(maxint / (base - t))) {\n                    throw RangeError('punycode_overflow(2)');\n                }\n                w *= base - t;\n            }\n\n            out = output.length + 1;\n            bias = adapt(i - oldi, out, oldi === 0);\n\n            // i was supposed to wrap around from out to 0,\n            // incrementing n each time, so we'll fix that now:\n            if (Math.floor(i / out) > maxint - n) {\n                throw RangeError('punycode_overflow(3)');\n            }\n            n += Math.floor(i / out);\n            i %= out;\n\n            // Insert n at position i of the output:\n            // Case of last character determines uppercase flag:\n            if (preserveCase) {\n                case_flags.splice(i, 0, input.charCodeAt(ic - 1) - 65 < 26);\n            }\n\n            output.splice(i, 0, n);\n            i++;\n        }\n        if (preserveCase) {\n            for (i = 0, len = output.length; i < len; i++) {\n                if (case_flags[i]) {\n                    output[i] = String.fromCharCode(output[i])\n                        .toUpperCase()\n                        .charCodeAt(0);\n                }\n            }\n        }\n        return this.utf16.encode(output);\n    };\n\n    //** Main encode function **\n\n    this.encode = function(input, preserveCase) {\n        //** Bias adaptation function **\n\n        var n, delta, h, b, bias, j, m, q, k, t, ijv, case_flags;\n\n        if (preserveCase) {\n            // Preserve case, step1 of 2: Get a list of the unaltered string\n            case_flags = this.utf16.decode(input);\n        }\n        // Converts the input in UTF-16 to Unicode\n        input = this.utf16.decode(input.toLowerCase());\n\n        var input_length = input.length; // Cache the length\n\n        if (preserveCase) {\n            // Preserve case, step2 of 2: Modify the list to true/false\n            for (j = 0; j < input_length; j++) {\n                case_flags[j] = input[j] != case_flags[j];\n            }\n        }\n\n        var output = [];\n\n        // Initialize the state:\n        n = initial_n;\n        delta = 0;\n        bias = initial_bias;\n\n        // Handle the basic code points:\n        for (j = 0; j < input_length; ++j) {\n            if (input[j] < 0x80) {\n                output.push(String.fromCharCode(case_flags ? encode_basic(input[j], case_flags[j]) : input[j]));\n            }\n        }\n\n        h = b = output.length;\n\n        // h is the number of code points that have been handled, b is the\n        // number of basic code points\n\n        if (b > 0) output.push(delimiter);\n\n        // Main encoding loop:\n        //\n        while (h < input_length) {\n            // All non-basic code points < n have been\n            // handled already. Find the next larger one:\n\n            for (m = maxint, j = 0; j < input_length; ++j) {\n                ijv = input[j];\n                if (ijv >= n && ijv < m) m = ijv;\n            }\n\n            // Increase delta enough to advance the decoder's\n            // <n,i> state to <m,0>, but guard against overflow:\n\n            if (m - n > Math.floor((maxint - delta) / (h + 1))) {\n                throw RangeError('punycode_overflow (1)');\n            }\n            delta += (m - n) * (h + 1);\n            n = m;\n\n            for (j = 0; j < input_length; ++j) {\n                ijv = input[j];\n\n                if (ijv < n) {\n                    if (++delta > maxint) return Error('punycode_overflow(2)');\n                }\n\n                if (ijv == n) {\n                    // Represent delta as a generalized variable-length integer:\n                    for (q = delta, k = base; ; k += base) {\n                        t = k <= bias ? tmin : k >= bias + tmax ? tmax : k - bias;\n                        if (q < t) break;\n                        output.push(String.fromCharCode(encode_digit(t + ((q - t) % (base - t)), 0)));\n                        q = Math.floor((q - t) / (base - t));\n                    }\n                    output.push(String.fromCharCode(encode_digit(q, preserveCase && case_flags[j] ? 1 : 0)));\n                    bias = adapt(delta, h + 1, h == b);\n                    delta = 0;\n                    ++h;\n                }\n            }\n\n            ++delta;\n            ++n;\n        }\n        return output.join('');\n    };\n\n    this.ToASCII = function(domain) {\n        var domain_array = domain.split('.');\n        var out = [];\n        for (var i = 0; i < domain_array.length; ++i) {\n            var s = domain_array[i];\n            out.push(s.match(/[^A-Za-z0-9-]/) ? 'xn--' + punycode.encode(s) : s);\n        }\n        return out.join('.');\n    };\n    this.ToUnicode = function(domain) {\n        var domain_array = domain.split('.');\n        var out = [];\n        for (var i = 0; i < domain_array.length; ++i) {\n            var s = domain_array[i];\n            out.push(s.match(/^xn--/) ? punycode.decode(s.slice(4)) : s);\n        }\n        return out.join('.');\n    };\n}\n\nconst punycode = new Punycode();\nexport default punycode;\n"]},"metadata":{},"sourceType":"module"}